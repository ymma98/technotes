# 基本概念-函数_预处理

## 函数传参

### pass by value

对象被复制，并赋值给方法 `f(T x)` 的输入参数 

优点：
-   在函数内对参数进行的更改不会影响到实参 

缺点：
-   如果复制的参数很大（例如，包含多个数据成员的结构体），将导致性能损失 

何时使用：
-   内置数据类型和小对象（≤ 8字节） 

何时不使用：
-   固定大小的数组，会退化成指针。低效，且不会保存数组的尺寸信息
-   大型对象

### pass by pointer

变量的地址被复制，并赋值给方法 `f(T* x)` 的输入参数 

优点：
-   允许函数改变实参的值
-   实参未被复制（速度快） 

缺点：
-   实参可能是空指针
-   解引用指针比直接访问值慢 

何时使用：
-   原始数组（如果是只读，使用 `const T*`） 

何时不使用：
-   其他所有情况

### pass by reference

变量的引用被复制，并赋值给方法 `f(T& x)` 的输入参数 

优点：
-   允许函数改变实参的值（与指针相比，可读性更好）
-   实参未被复制（速度快）
-   引用必须初始化（没有空指针）
-   避免了隐式转换（非 const T& 的情况） 

何时使用：
-   除原始指针外的所有情况 

何时不使用：
-   通过值传递可能带来性能优势，并且在内置数据类型和小型对象（容易复制的对象）使用时，可以提高可读性


```cpp
struct MyStruct;
void f1(int a); // pass by-value
void f2(int& a); // pass by-reference
void f3(const int& a); // pass by-const reference
void f4(MyStruct& a); // pass by-reference
void f5(int* a); // pass by-pointer
void f6(const int* a); // pass by-const pointer
void f7(MyStruct* a); // pass by-pointer
void f8(int*& a); // pass a pointer by-reference
//--------------------------------------------------------------
char c = 'a';
f1(c); // ok, pass by-value (implicit conversion)
// f2(c); // compile error different types
f3(c); // ok, pass by-value (implicit conversion) 
```

## 函数签名与重载

**函数签名 (signature)** 定义了（特定的）函数的输入类型，以及模板函数的输入和输出类型。

 一个函数签名包括参数的数量、参数的类型以及参数的顺序。

-   C++标准禁止仅在返回类型上有差异的函数声明
-   具有不同签名的函数声明可以有不同的返回类型

**函数重载  (overloading)** 允许使用相同名称但具有不同签名的多个不同函数

```cpp
void f(int a, char* b); // signature: (int, char*)
// char f(int a, char* b); // compile error same signature
							// but different return types
void f(const int a, char* b); // same signature, ok
								// const int == int
void f(int a, const char* b); // overloading with signature: (int, const char*)
int f(float); // overloading with signature: (float)
				// the return type is different
```

在 C++ 中，`=delete` 关键字用于显式地删除某个函数，以禁止使用某些函数重载，增强代码安全性和清晰度。

```cpp
void g(int) {}
void g(double) = delete;
g(3);    // ok
g(3.0);  // compile error
```

```cpp
#include <cstddef> // std::nullptr_t
void f(int*) {}
void f(std::nullptr_t) = delete;
f(nullptr); // compile error
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTI2MzU0Nzg2MywtMTg0MTIwMzcyMywxNT
A3Mjc0NDkyLDE4NTQwNDc2MDFdfQ==
-->