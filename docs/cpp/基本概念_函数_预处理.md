# 基本概念-函数_预处理

## 函数传参

### pass by value

对象被复制，并赋值给方法 `f(T x)` 的输入参数 

优点：
-   在函数内对参数进行的更改不会影响到实参 

缺点：
-   如果复制的参数很大（例如，包含多个数据成员的结构体），将导致性能损失 

何时使用：
-   内置数据类型和小对象（≤ 8字节） 

何时不使用：
-   固定大小的数组，会退化成指针。低效，且不会保存数组的尺寸信息
-   大型对象

### pass by pointer

变量的地址被复制，并赋值给方法 `f(T* x)` 的输入参数 

优点：
-   允许函数改变实参的值
-   实参未被复制（速度快） 

缺点：
-   实参可能是空指针
-   解引用指针比直接访问值慢 

何时使用：
-   原始数组（如果是只读，使用 `const T*`） 

何时不使用：
-   其他所有情况

### pass by reference

变量的引用被复制，并赋值给方法 `f(T& x)` 的输入参数 

优点：
-   允许函数改变实参的值（与指针相比，可读性更好）
-   实参未被复制（速度快）
-   引用必须初始化（没有空指针）
-   避免了隐式转换（非 const T& 的情况） 

何时使用：
-   除原始指针外的所有情况 

何时不使用：
-   通过值传递可能带来性能优势，并且在内置数据类型和小型对象（容易复制的对象）使用时，可以提高可读性


```cpp
struct MyStruct;
void f1(int a); // pass by-value
void f2(int& a); // pass by-reference
void f3(const int& a); // pass by-const reference
void f4(MyStruct& a); // pass by-reference
void f5(int* a); // pass by-pointer
void f6(const int* a); // pass by-const pointer
void f7(MyStruct* a); // pass by-pointer
void f8(int*& a); // pass a pointer by-reference
//--------------------------------------------------------------
char c = 'a';
f1(c); // ok, pass by-value (implicit conversion)
// f2(c); // compile error different types
f3(c); // ok, pass by-value (implicit conversion) 
```

### 函数签名与重载

**函数签名 (signature)** 定义了（特定的）函数的输入类型，以及模板函数的输入和输出类型。

 一个函数签名包括参数的数量、参数的类型以及参数的顺序。

-   C++标准禁止仅在返回类型上有差异的函数声明
-   具有不同签名的函数声明可以有不同的返回类型

**函数重载  (overloading)** 允许使用相同名称但具有不同签名的多个不同函数

```cpp
void f(int a, char* b); // signature: (int, char*)
// char f(int a, char* b); // compile error same signature
							// but different return types
void f(const int a, char* b); // same signature, ok
								// const int == int
void f(int a, const char* b); // overloading with signature: (int, const char*)
int f(float); // overloading with signature: (float)
				// the return type is different
```

在 C++ 中，`=delete` 关键字用于显式地删除某个函数，以禁止使用某些函数重载，增强代码安全性和清晰度。

```cpp
void g(int) {}
void g(double) = delete;
g(3);    // ok
g(3.0);  // compile error
```

```cpp
#include <cstddef> // std::nullptr_t
void f(int*) {}
void f(std::nullptr_t) = delete;
f(nullptr); // compile error
```

### 函数的默认参数

默认参数是一个具有默认值的函数参数。

-   如果用户没有为这个参数提供值，将使用默认值
-   所有默认参数必须是最右边的参数
-   默认参数只能声明一次
-   默认参数可以提高编译时间并避免冗余代码，因为它们避免了定义其他重载函数

```cpp
void f(int a, int b = 20); // 声明
//void f(int a, int b = 10) { ... } // 编译错误，b的默认值已在声明中设置
void f(int a, int b) { ... } // 定义，b的默认值已经设置
f(5); // b 是 20
```

## C 中的函数指针

标准C通过函数指针的概念实现了泛型编程能力和可组合性。 

一个函数可以作为指针传递给另一个函数，并作为“间接调用”执行。

```c
#include <stdlib.h> // qsort
int descending(const void* a, const void* b) {
    return *((const int*) a) > *((const int*) b);
}
int array[] = {7, 2, 5, 1};
qsort(array, 4, sizeof(int), descending);
// 数组变为：{ 7, 5, 2, 1 }
```

```c
int eval(int a, int b, int (*f)(int, int)) {
    return f(a, b);
}
// 类型：int (*)(int, int)
int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
cout << eval(4, 3, add); // 输出 7
cout << eval(4, 3, sub); // 输出 1
```

问题：
-   安全性：在泛型情况下没有对参数类型的检查（例如，qsort）
-   性能：任何操作都需要对原始函数进行间接调用。不可能进行函数内联
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTAzNDE5MjMxNSwtMTg0MTIwMzcyMywxNT
A3Mjc0NDkyLDE4NTQwNDc2MDFdfQ==
-->