# 模板元编程


模板 (template) 是 C++ 中用于泛型编程的机制，提供了一种“模式 (schema)”（或占位符 placeholder），用于表示实体的结构。模板是编译时功能，用于表示：

- 函数族 (family of functions)
- 类族 (family of classes)
- C++14 开始的变量族 (family of variables)


模板允许程序员编写与数据类型无关的代码，从而提高代码的复用性和灵活性。使用模板可以定义函数模板、类模板以及变量模板，这些模板在编译时根据实际使用的数据类型自动实例化。





## 函数模板




函数模板 (function template) 是一种通用类型的函数架构，可以与多种数据类型一起工作，而无需为每种类型重复整个代码。


```cpp
template<typename T> // 或 template<class T>
T add(T a, T b) {
    return a + b;
}

int c1 = add(3, 4); // c1 = 7
float c2 = add(3.0f, 4.0f); // c2 = 7.0f
```

模板实例化是用具体值或类型替换模板参数的过程。编译器会自动为每个模板实例生成一个函数实现。

```cpp
template<typename T>
T add(T a, T b) {
    return a + b;
}

add(3, 4); // 生成：int add(int, int)
add(3.0f, 4.0f); // 生成：float add(float, float)
add(2, 6); // 已经生成
// 不生成其他实例
// 例如：char add(char, char) 尚未生成
```



### C++ 模板实例化

模板实例化是指编译器根据模板参数生成具体代码的过程。在 C++ 中，模板实例化可以是隐式的也可以是显式的。

* 隐式模板实例化

当编译器根据推断出的参数类型或明确的模板参数生成代码，并且只在定义被需要时进行，这称为隐式模板实例化。


```cpp
template<typename T>
void f(T a) {}

void g() {
    f(3); // 隐式生成：void f(int)
    f<short>(3.0); // 隐式生成：void f(short)
}

template void f<int>(int); // 显式生成：void f(int)
```

* 显式模板实例化

显式模板实例化发生在编译器根据声明中指定的显式模板参数生成代码。这在处理多个翻译单元时非常有用，可以减少二进制大小。



### 模板参数
模板参数是在 `template` 关键字后定义的名称。

```cpp
template<typename T>
void f() {}
f<int>(); // typename T 是模板参数，int 是模板参数实例
```

模板参数可以是泛型类型，例如 `typename` 或 `class`，也可以是非类型模板参数（NTTP），如 `int`、`enum` 等。
```cpp
template<int A, int B>
int add_int() {
    return A + B; // 在编译时计算
} // 示例：add_int<3, 4>();

enum class Enum { Left, Right };
template<Enum Z>
int add_enum(int a, int b) {
    return (Z == Enum::Left) ? a + b : a;
} // 示例：add_enum<Enum::Left>(3, 4);
```

* 带有默认值的模板参数（C++11）
```cpp
template<int A = 3, int B = 4>
void print1() { cout << A << ", " << B; }
print1<2, 5>(); // 打印 2, 5
print1<2>(); // 打印 2, 4 (B 有默认值)
print1<>(); // 打印 3, 4 (A, B 都有默认值)
print1(); // 打印 3, 4 (A, B 都有默认值)
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE2MTI2OTc5NTMsNjA4NTkzMjY3XX0=
-->