# 翻译单元

## 基本概念

区分三个概念: scope (变量在什么范围内有效)、duration (变量什么时候分配和释放)、linkage (变量对于外部翻译单元是否可见)

-   翻译单元 (translation unit) 是C++中的基本编译单位。它由**单个源文件的内容，加上该源文件直接或间接包含的任何头文件的内容组成**。一个翻译单元可以被编译成对象文件、库文件或可执行程序。

-   Header File（头文件）。头文件允许**定义接口** (interface)，文件扩展名通常为 `.h`、`.hpp` 或 `.hxx`。它们用于声明函数、类以及其他类型的接口，而具体的实现则保留在分离的源文件中。
    
-   Source File（源文件）。源文件包含具体的实现代码，文件扩展名可能为 `.c`、`.cpp` 或 `.cxx`。源文件中包含从头文件中引入的声明的具体实现。

* 一个典型的编译过程:

![输入图片说明](./imgs/2024-07/iUspa7o9cJJXjhej.png)



* Scope（作用域），是指在代码中可以访问变量、函数或对象的区域。


-   Local Scope / Block Scope（局部作用域 / 块作用域），在函数或代码块内声明的实体称为局部变量。它们只在声明它们的函数或代码块内有效，其内存地址在作用域之外无效。


-   Global Scope / File Scope / Namespace Scope（全局作用域 / 文件作用域 / 命名空间作用域）: 在所有函数外部定义的实体。这些实体在程序的整个生命周期内保持单一的内存位置。

```cpp
int var1; // global scope
int f() {
	int var2; // local scope
}
struct A {
	int var3; // depends on where the instance of 'A' is used
};
```


-   Linkage（链接） 。 链接是指符号对链接器的可见性 (visibility)。

-   No Linkage（无链接）：无链接是指局部作用域内的符号，对链接器不可见。
	- 局部变量、函数、类在定义它们的作用域内有效，不可在其他翻译单元中访问。
	- 静态局部变量（static local variable）的地址取决于其所在函数的链接性。

-   Internal Linkage（内部链接）。内部链接是指只在单个翻译单元的作用域内可见的符号。相同的符号名称在不同翻译单元中具有不同的内存地址。

-   External Linkage（外部链接）。外部链接是指存在于单个翻译单元之外的实体。这些实体在整个程序中可访问，并且在所有翻译单元的组合中具有相同的内存地址。

## 存储类别与期限 (storage class and duration)


-   Storage Duration（存储期限）。存储期限（或称持续性类别, duration class）决定了一个变量的生命周期，即变量何时被创建和销毁。


-   Automatic Storage Duration（自动存储期限） 。局部变量临时分配在寄存器或栈上（取决于编译器、架构等）。如果没有明确初始化，它们的值是未定义的。

-   Static Storage Duration（静态存储期限）。当程序开始时分配对象的存储空间，程序结束时释放。如果没有明确初始化，它将进行零初始化。


-   Dynamic Storage Duration（动态存储期限）。对象的分配和释放通过使用动态内存分配函数（如 `new`/`delete`）进行。如果没有明确初始化，其内存内容是未定义的。


-   (C++11) Thread Storage Duration（线程存储期限）。对象在线程开始时分配，在线程结束时释放。每个线程拥有对象的自己的实例。

| Storage Duration | Allocation | Deallocation |
| :--- | :--- | :--- |
| Automatic | Code block start | Code block end |
| Static | Program start | Program end |
| Dynamic | Memory allocation | Memory deallocation |
| Thread | Thread start | Thread end |


```cpp
int v1; // static duration
void f() {
    int v2; // automatic duration
    auto v3 = 3; // automatic duration
    auto array = new int[10]; // dynamic duration (allocation)
} // array, v2, v3 variables deallocation (from stack)
// the memory associated to "array" is not deallocated
int main() {
    f();
}
// main end: v1 is deallocated
```


* Storage Class Specifier（存储类说明符）: 存储类说明符是一种类型说明符，与作用域一起，决定了变量的存储期限和链接方式。

| Storage Class | Notes | Scope | Storage Duration | Linkage |
| :--- | :--- | :--- | :--- | :--- |
| auto | local var decl. | Local | automatic | No linkage |
| no storage class | global var decl. | Global | static | External |
| static |  | Local | static | Function |
| static |  | Global | static | Dependent |
| extern |  | Global | static | External |
| thread_local | C ++11 | any | thread local | any |


```cpp
int v1; // no storage class
static int v2 = 2; // static storage class
extern int v3; // external storage class
thread_local int v4; // thread local storage class
thread_local static int v5; // thread local and static storage classes
int main() {
    int v6; // auto storage class
    auto v7 = 3; // auto storage class
    static int v8; // static storage class
    thread_local int v9; // thread local and auto storage classes
    auto array = new int[10]; // auto storage class ("array" variable)
}
```

* `static` 类型的局部变量在程序开始运行时分配，当函数第一次执行时初始化，在程序结束时释放。
```cpp
int f() {
    static int val = 1;
    val++;
    return val;
}
int main() {
    cout << f(); // print 2 ("val" is initialized)
    cout << f(); // print 3
    cout << f(); // print 4
}
```

- `static` / 匿名 (anonymous) 命名空间中的全局变量或函数仅在所在文件中可见，具有内部链接性（internal linkage）。
- 非`static`的全局变量或函数若在不同的翻译单元中具有相同的名称，则会产生名称冲突（name collision）。
- `extern` 关键字用于声明另一个翻译单元中存在的全局变量或函数，表示具有外部链接性（external linkage）。
  - **变量必须在某个翻译单元中定义一次且仅一次**。
  - 对于函数而言，使用 `extern` 是多余的。
  - 对于变量而言，使用 `extern` 是必要的，以防止编译器在当前翻译单元中分配内存地址。

如果同一个标识符在一个翻译单元中同时具有内部链接性和外部链接性，其行为是未定义的（undefined behavior）。

示例代码：

```c++
int var1 = 3; // 外部链接性 (与其他翻译单元中同名变量冲突)
static int var2 = 4; // 内部链接性 (仅在当前翻译单元中可见)
extern int var3; // 外部链接性 (在另一个翻译单元中实现)
void f1() {} // 外部链接性 (可能会与其他单元冲突)
static void f2() {} // 内部链接性
namespace { // 匿名命名空间
    void f3() {} // 内部链接性
}
extern void f4(); // 外部链接性 (在另一个翻译单元中实现)
```


## `const` 与 `constexpr` 变量的链接

- `const`变量在全局作用域具有内部链接性（internal linkage）。
- `constexpr`变量隐含为`const`，也具有内部链接性。
- 注意：同一个变量在不同的翻译单元中拥有不同的内存地址，这可能导致代码膨胀（code bloat）。


```c++
const int var1 = 3; // 内部链接性
constexpr int var2 = 2; // 内部链接性
static const int var3 = 3; // 内部链接性（冗余）
static constexpr int var4 = 2; // 内部链接性（冗余）
int main() {}
```


在C++中，全局变量在运行时的初始化顺序是未定义的。这可能引起一个称为“静态初始化顺序问题”（static initialization order fiasco）的问题，这种问题发生在全局变量跨多个文件时，其初始化顺序取决于链接器的链接顺序，可能导致不可预知的行为。

示例代码解释：

- source.cpp
```c++
  int f() { return 3; } // 运行时函数
  int x = f(); // 运行时评估
```
* main.cpp
```cpp
extern int x;
int y = x; // 运行时初始化
int main() {
    cout << y; // 根据链接顺序，可能打印 "3" 或 "0"
}
```

在这种情况下，如果`main.cpp`在`source.cpp`之前被初始化，则`y`可能未正确初始化而是打印“0”。




无链接性（No Linkage）：


内部链接性（Internal Linkage）：
- 在其他翻译单元中不可访问，避免了名称冲突，各自有不同的内存地址。
- 全局变量：
  - 使用`static`修饰符。
  - 常量（const）、常量表达式（constexpr）（非内联（inline）、非模板（template）、非特化（specialized）、非外部（extern））。
- 函数：
  - 使用`static`修饰符。
- 匿名命名空间的内容，包括结构体和类。

外部链接性（External Linkage）：
- 可以被其他翻译单元访问，可能会产生名称冲突，具有相同的内存地址。
- 全局变量：
  - 无修饰符或使用`extern`修饰符。
  - 模板/特化（C++14）（模板变量按一次定义规则（ODR）处理，不会冲突）。
  - C++17起，内联的常量（inline const）/常量表达式（constexpr）（按ODR处理，不会冲突）。
- 函数：
  - 无修饰符（内联函数按ODR处理，不冲突），或使用`extern`修饰符。
  - 模板/特化（按ODR处理，不冲突）。
- 注意：内联函数（inline）、常量表达式函数（constexpr，暗示内联）即使具有外部链接性，也不可在其他翻译单元中访问。
- 枚举类型、类及其静态和非静态成员。

这些信息为您提供了关于C++变量和函数链接性的详细解释，帮助您理解在多翻译单元项目中如何处理全局和局部作用域问题。

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTUyNjI0OTY3MiwtMTkwODQ2ODMzMSw2OD
I1NzYyNDUsNDA4NTg0ODkxLDc5NjMyNzE4MCwxNjM4Nzc0Njc3
LDE3NTIyOTM3M119
-->