# step3

## step-3


* 有限元方法的基本设置

我们将解决一个简单版本的泊松方程，其边界值为零，但右侧为非零：

$$
-\Delta u = f = 0 \text{ in } \Omega,\\
u=0 \text{ on } \partial\Omega.
$$

我们将在正方形 $\Omega = [-1, 1]^2$ 上解决此方程。在这个程序中，我们还将仅考虑特定情况 $f(x) = 1$，并将在下一个教程程序中回到如何实现更一般的情况。

如果您已经学习了有限元方法的基础，您会记得我们需要采取的步骤，以通过**有限维逼近来近似解 $u$**。具体来说，我们首先需要推导上述方程的弱形式，方法是将方程从左侧乘以测试函数 $\varphi$ 并在区域 $\Omega$ 上积分：

$$
-\int_\Omega \varphi \Delta u = \int_\Omega \varphi f.
$$

这可以通过分部积分得到：

$$
\int_\Omega \nabla \varphi \cdot \nabla u - \int_{\partial\Omega} \varphi \vec{n} \cdot \nabla u = \int_\Omega \varphi f.
$$

测试函数 $\varphi$ 必须满足相同类型的边界条件（在数学术语中：它需要来自我们寻求解的集合的切空间），因此在边界上 $\varphi = 0$，因此我们要寻找的弱形式为

$$(\nabla \varphi, \nabla u) = (\varphi, f),$$

这里我们使用了**常用的符号 $(a, b) = \int_\Omega ab$**。该问题要求寻找一个函数 $u$，使得对于来自适当空间（这里是 $H^1$ 空间）的所有测试函数 $\varphi$，该语句都成立。

当然，在一般情况下我们无法在计算机上找到这样的函数，而是我们寻求一个逼近 $u_h(x) = \sum_j U_j \varphi_j(x)$，其中 $U_j$ 是我们需要确定的未知扩展系数（该问题的“自由度”），而 $\varphi_i(x)$ 是我们将使用的有限元形状函数。为了定义这些形状函数，我们需要以下内容：

1. 一个定义形状函数的网格。
2. 一个描述我们希望在参考单元（在 deal.II 中始终是单位区间 $[0,1]$、单位正方形 $[0,1]^2$ 或单位立方体 $[0,1]^3$，具体取决于您所工作空间的维度）上使用的形状函数的有限元。在步骤 2 中，我们已经使用了类型为 `FE_Q<2>` 的对象，它表示通过对支持点的插值定义形状函数的常规拉格朗日元素。最简单的是 `FE_Q<2>(1)`，它使用多项式度为 1。在 2D 中，这些通常被称为双线性，因为它们在参考单元的两个坐标上是线性的。（在 1D 中，它们是线性的，在 3D 中是三线性的；然而，在 deal.II 文档中，我们通常不会做这种区分，而是简单地将这些函数称为“线性”的。）
3. 一个 `DoFHandler` 对象，用于枚举网格上的所有自由度，以有限元对象提供的参考单元描述为基础。您在步骤 2 中也已经看到如何做到这一点。
4. 一个映射，告诉我们如何从参考单元上有限元类定义的形状函数获取实际单元上的形状函数。默认情况下，除非您明确说明，否则 deal.II 将使用（双、三）线性映射，因此在大多数情况下您不必担心这一步。

通过这些步骤，我们现在拥有一组函数 $\varphi_i$，我们可以定义离散问题的弱形式：寻找一个函数 $u_h$，即寻找上述提到的扩展系数 $U_j$，使得

$$
(\nabla \varphi_i, \nabla u_h) = (\varphi_i, f), \quad i = 0 \ldots N-1.
$$

请注意，我们在这里遵循的约定是所有计数从零开始，这在 C 和 C++ 中很常见。通过插入表示 $u_h(x) = \sum_j U_j \varphi_j(x)$，然后观察到

$$
(\nabla \varphi_i, \nabla u_h) = (\nabla \varphi_i, \nabla[\sum_j U_j \varphi_j]) = \sum_j (\nabla \varphi_i, \nabla[U_j \varphi_j]) = \sum_j (\nabla \varphi_i, \nabla \varphi_j) U_j.
$$

因此，该问题变为：寻找一个向量 $U$ 使得

$$
AU = F,
$$

其中矩阵 $A$ 和右侧 $F$ 定义为

$$
A_{ij} = (\nabla \varphi_i, \nabla \varphi_j), \quad F_i = (\varphi_i, f).
$$

* 我们应该从左侧还是右侧乘以测试函数？

在继续描述如何计算这些量之前，请注意，如果我们将原始方程从右侧乘以测试函数而不是从左侧乘以，那么我们将得到形如

$$
U^T A = F^T
$$

的线性系统。通过转置该系统，这当然等同于解决

$$
A^T U = F
$$

这在这里与上面相同，因为 $A = A^T$。但在一般情况下并非如此，**为了避免任何混淆，经验表明，养成从左侧乘以方程而不是从右侧乘以（如数学文献中常做的）可以避免一种常见的错误，因为矩阵在比较理论和实现时自动正确，而不需要转置**。请参见步骤 9 中本教程的第一个示例，其中我们有一个非对称双线性形式，此时从右侧乘以或从左侧乘以是有区别的。


* 组装矩阵和右侧向量

现在我们知道我们需要什么（即：用于存储矩阵和向量的对象，以及计算 $A_{ij},F_i$ 的方法），我们可以看看实现这一目标需要什么：

- 对于 $A$ 的对象是 SparseMatrix 类型，而 $U$ 和 $F$ 的对象是 Vector 类型。我们将在下面的程序中看到用于求解线性系统的类。
- 我们需要一种形成积分的方法。在有限元方法中，这通常是通过求积来完成的，即用一组每个单元上的求积点的加权和来替代积分。也就是说，我们首先将 $\Omega$ 上的积分拆分为对所有单元的积分，
  $$ 
  \begin{align*}
    A_{ij} &= (\nabla\varphi_i, \nabla \varphi_j) 
    = \sum_{K \in {\mathbb T}} \int_K \nabla\varphi_i \cdot \nabla \varphi_j, \\
    F_i &= (\varphi_i, f) 
    = \sum_{K \in {\mathbb T}} \int_K \varphi_i f,
  \end{align*}
  $$
  然后用求积来近似每个单元的贡献：
  $$
  \begin{align*}
    A^K_{ij} &=
    \int_K \nabla\varphi_i \cdot \nabla \varphi_j 
    \approx 
    \sum_q \nabla\varphi_i(\mathbf x^K_q) \cdot \nabla 
    \varphi_j(\mathbf x^K_q) w_q^K, \\
    F^K_i &=
    \int_K \varphi_i f 
    \approx 
    \sum_q \varphi_i(\mathbf x^K_q) f(\mathbf x^K_q) w^K_q,
  \end{align*}
  $$
  其中 $\mathbb{T} \approx \Omega$ 是一个近似于域的三角剖分，$\mathbf x^K_q$ 是单元 $K$ 上的第 $q$ 个求积点，$w^K_q$ 是第 $q$ 个求积权重。完成这一过程需要不同的部分，我们将依次讨论它们。
- 首先，我们需要一种描述求积点位置 $\mathbf x_q^K$ 和它们权重 $w^K_q$ 的方法。它们通常通过与形状函数相同的方式从参考单元映射而来，即隐式地使用 MappingQ1 类，或者如果你明确说明，则通过从 Mapping 派生的其他类。参考单元上的位置和权重由从 Quadrature 基类派生的对象描述。通常，我们选择一种求积公式（即一组点和权重），以使得求积与矩阵中的积分完全相等；这可以通过高斯求积公式实现，该公式在 QGauss 类中实现。
- 然后，我们需要一些东西来帮助我们在单元 $K$ 上评估 $\varphi_i(\mathbf x^K_q)$。这就是 FEValues 类的作用：它接收一个有限元对象来描述参考单元上的 $\varphi$，一个求积对象来描述求积点和权重，以及一个映射对象（或隐式使用 MappingQ1 类），并提供在单元 $K$ 上的求积点位置的形状函数值和导数，以及进行积分所需的各种其他信息。

计算矩阵和右侧向量的过程是对所有单元（然后对求积点的求和）的求和，通常称为 *组装线性系统*，或简称为 *组装*，其含义与 [装配线](https://en.wikipedia.org/wiki/Assembly_line) 相关，意味着“将一组片段或元素组装在一起的行为”。

FEValues 确实是组装过程中的核心类。你可以这样来看待它：有限元及其派生类描述形状 <i>函数</i>，即无限维对象：函数在每个点都有值。我们需要这一点是出于理论原因，因为我们希望通过函数的积分进行分析。然而，对于计算机来说，这是一个非常困难的概念，因为它们通常只能处理有限的信息，因此我们用在参考单元上定义的点（由 Quadrature 对象）映射到实际单元上的求积点来替代积分。实质上，我们将问题简化为只需要有限的信息，即形状函数值和导数、求积权重、法向量等，这些信息仅在有限的一组点上。FEValues 类将这三个组件结合在一起，并提供特定单元 $K$ 上的这组有限信息。当我们组装下面的线性系统时，你将看到它的实际应用。

值得注意的是，如果你在应用程序中自己创建这三个对象并自行处理信息，这一切也是可以实现的。然而，这既不会更简单（FEValues 类正好提供了你实际需要的信息）也不会更快：FEValues 类经过高度优化，只计算每个单元所需的特定信息；如果从前一个单元可以重用任何信息，它将这样做，并且该类中有大量代码确保在有利的情况下缓存信息。

本介绍的最后一点是提到，在线性系统获得后，它是通过迭代求解器进行求解的，然后进行后处理：我们使用 DataOut 类创建一个输出文件，可以通过常见的可视化程序进行可视化。

> **注意**：以上关于任何有限元实现的重要步骤概述在 deal.II 中也有其对应部分：该库自然可以分为若干个覆盖上述基本概念的“模块”。你可以通过本页顶部的标签访问这些模块。最基本概念组的概述也可以在 [deal.II 手册的首页](index.html) 上找到。

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwMjkyNTMyMzYsLTE5MTk0NjQ0MzQsMj
A5NTQ2NjQ0LC03OTMxMTYyNDAsLTg4ODA1NjAwNl19
-->