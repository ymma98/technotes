# step3

## step-3


* 有限元方法的基本设置

我们将解决一个简单版本的泊松方程，其边界值为零，但右侧为非零：

$$
-\Delta u = f = 0 \text{ in } \Omega,\\
u=0 \text{ on } \partial\Omega.
$$

我们将在正方形 $\Omega = [-1, 1]^2$ 上解决此方程。在这个程序中，我们还将仅考虑特定情况 $f(x) = 1$，并将在下一个教程程序中回到如何实现更一般的情况。

如果您已经学习了有限元方法的基础，您会记得我们需要采取的步骤，以通过**有限维逼近来近似解 $u$**。具体来说，我们首先需要推导上述方程的弱形式，方法是将方程从左侧乘以测试函数 $\varphi$ 并在区域 $\Omega$ 上积分：

$$
-\int_\Omega \varphi \Delta u = \int_\Omega \varphi f.
$$

这可以通过分部积分得到：

$$
\int_\Omega \nabla \varphi \cdot \nabla u - \int_{\partial\Omega} \varphi \vec{n} \cdot \nabla u = \int_\Omega \varphi f.
$$

测试函数 $\varphi$ 必须满足相同类型的边界条件（在数学术语中：它需要来自我们寻求解的集合的切空间），因此在边界上 $\varphi = 0$，因此我们要寻找的弱形式为

$$(\nabla \varphi, \nabla u) = (\varphi, f),$$

这里我们使用了**常用的符号 $(a, b) = \int_\Omega ab$**。该问题要求寻找一个函数 $u$，使得对于来自适当空间（这里是 $H^1$ 空间）的所有测试函数 $\varphi$，该语句都成立。

当然，在一般情况下我们无法在计算机上找到这样的函数，而是我们寻求一个逼近 $u_h(x) = \sum_j U_j \varphi_j(x)$，其中 $U_j$ 是我们需要确定的未知扩展系数（该问题的“自由度”），而 $\varphi_i(x)$ 是我们将使用的有限元形状函数。为了定义这些形状函数，我们需要以下内容：

1. 一个定义形状函数的网格。
2. 一个描述我们希望在参考单元（在 deal.II 中始终是单位区间 $[0,1]$、单位正方形 $[0,1]^2$ 或单位立方体 $[0,1]^3$，具体取决于您所工作空间的维度）上使用的形状函数的有限元。在步骤 2 中，我们已经使用了类型为 `FE_Q<2>` 的对象，它表示通过对支持点的插值定义形状函数的常规拉格朗日元素。最简单的是 `FE_Q<2>(1)`，它使用多项式度为 1。在 2D 中，这些通常被称为双线性，因为它们在参考单元的两个坐标上是线性的。（在 1D 中，它们是线性的，在 3D 中是三线性的；然而，在 deal.II 文档中，我们通常不会做这种区分，而是简单地将这些函数称为“线性”的。）
3. 一个 `DoFHandler` 对象，用于枚举网格上的所有自由度，以有限元对象提供的参考单元描述为基础。您在步骤 2 中也已经看到如何做到这一点。
4. 一个映射，告诉我们如何从参考单元上有限元类定义的形状函数获取实际单元上的形状函数。默认情况下，除非您明确说明，否则 deal.II 将使用（双、三）线性映射，因此在大多数情况下您不必担心这一步。

通过这些步骤，我们现在拥有一组函数 $\varphi_i$，我们可以定义离散问题的弱形式：寻找一个函数 $u_h$，即寻找上述提到的扩展系数 $U_j$，使得

$$
(\nabla \varphi_i, \nabla u_h) = (\varphi_i, f), \quad i = 0 \ldots N-1.
$$

请注意，我们在这里遵循的约定是所有计数从零开始，这在 C 和 C++ 中很常见。通过插入表示 $u_h(x) = \sum_j U_j \varphi_j(x)$，然后观察到

$$
(\nabla \varphi_i, \nabla u_h) = (\nabla \varphi_i, \nabla[\sum_j U_j \varphi_j]) = \sum_j (\nabla \varphi_i, \nabla[U_j \varphi_j]) = \sum_j (\nabla \varphi_i, \nabla \varphi_j) U_j.
$$

因此，该问题变为：寻找一个向量 $U$ 使得

$$
AU = F,
$$

其中矩阵 $A$ 和右侧 $F$ 定义为

$$
A_{ij} = (\nabla \varphi_i, \nabla \varphi_j), \quad F_i = (\varphi_i, f).
$$

* 我们应该从左侧还是右侧乘以测试函数？

在继续描述如何计算这些量之前，请注意，如果我们将原始方程从右侧乘以测试函数而不是从左侧乘以，那么我们将得到形如

$$
U^T A = F^T
$$

的线性系统。通过转置该系统，这当然等同于解决

$$
A^T U = F
$$

这在这里与上面相同，因为 $A = A^T$。但在一般情况下并非如此，**为了避免任何混淆，经验表明，养成从左侧乘以方程而不是从右侧乘以（如数学文献中常做的）可以避免一种常见的错误，因为矩阵在比较理论和实现时自动正确，而不需要转置**。请参见步骤 9 中本教程的第一个示例，其中我们有一个非对称双线性形式，此时从右侧乘以或从左侧乘以是有区别的。


* 组装矩阵和右侧向量

现在我们知道我们需要什么（即：保存矩阵和向量的对象，以及计算 \(A_{ij}\) 和 \(F_i\) 的方法），我们可以看看实现这些所需的内容：

矩阵 \(A\) 的对象类型为 `SparseMatrix`，而 \(U\) 和 \(F\) 的对象类型为 `Vector`。我们将在下面的程序中看到用于求解线性系统的类。

我们需要一种方法来形成积分。在有限元方法中，这通常使用数值积分进行，即用在每个单元上的一组数值点的加权和来替代积分。也就是说，我们首先将区域 \(\Omega\) 上的积分拆分为所有单元上的积分，

$$
A_{ij} = (\nabla \phi_i, \nabla \phi_j) = \sum_{K \in T} \int_K \nabla \phi_i \cdot \nabla \phi_j, \quad F_i = (\phi_i, f) = \sum_{K \in T} \int_K \phi_i f,
$$

然后通过数值积分来近似每个单元的贡献：

$$
A_{Kij} \approx \int_K \nabla \phi_i \cdot \nabla \phi_j \approx \sum_q \nabla \phi_i(x_{Kq}) \cdot \nabla \phi_j(x_{Kq}) w_{Kq}, \quad F_K \approx \int_K \phi_i f \approx \sum_q \phi_i(x_{Kq}) f(x_{Kq}) w_{Kq},
$$

其中 \(T \approx \Omega\) 是一个近似域的三角剖分，\(x_{Kq}\) 是单元 \(K\) 上的第 \(q\) 个数值点，\(w_{Kq}\) 是第 \(q\) 个数值权重。进行这些步骤所需的不同部分我们将依次讨论。

首先，我们需要一种描述数值点位置 \(x_{Kq}\) 及其权重 \(w_{Kq}\) 的方法。它们通常通过参考单元进行映射，与形状函数的方式相同，即通过 `MappingQ1` 类隐式使用，或者如果您明确指定，则通过其他派生自 `Mapping` 的类。参考单元上的位置和权重由派生自 `Quadrature` 基类的对象描述。通常，选择一个数值公式（即一组点和权重）以确保数值积分完全等于矩阵中的积分；这可以通过高斯数值积分公式实现，这在 `QGauss` 类中已实现。

然后，我们需要一些东西来帮助我们在单元 \(K\) 上评估 \(\phi_i(x_{Kq})\)。这就是 `FEValues` 类的作用：它接受有限元对象来描述参考单元上的 \(\phi\)，一个数值对象来描述数值点和权重，以及一个映射对象（或隐式采用 `MappingQ1` 类），并在位于 \(K\) 的数值点上提供形状函数的值和导数，以及进行积分所需的其他各种信息。

计算矩阵和右侧的过程通常称为组装线性系统，简称为“组装”，使用与生产线相关的单词含义，意味着“将一组片段、碎片或元素组合在一起的行为”。

`FEValues` 确实是组装过程中核心的类。您可以将其视为：有限元及其派生类描述形状函数，即无限维对象：函数在每个点上都有值。我们出于理论原因需要这样做，因为我们希望通过对函数的积分进行分析。然而，对于计算机来说，这是一个非常困难的概念，因为它们一般只能处理有限数量的信息，因此我们通过对我们从参考单元（由 `Quadrature` 对象定义）映射到实际单元的数值点进行求和来替代积分。实质上，我们将问题简化为只需要有限数量的信息，即形状函数值和导数、数值权重、法向量等，仅在有限集合的点上。`FEValues` 类将这三个组件结合在一起，并在特定单元 \(K\) 上提供这一有限的信息集。您将在下面组装线性系统时看到它的实际运作。

值得注意的是，如果您在应用程序中自己创建这三个对象，并自行处理信息，也可以实现这一切。然而，这既不会更简单（`FEValues` 类提供了您实际需要的信息），也不会更快：`FEValues` 类经过高度优化，仅计算每个单元所需的特定信息；如果可以重用上一个单元的信息，它将这样做，而该类中有大量代码确保在有利的地方进行缓存。

这一介绍的最后一部分是提到，在获得线性系统后，通过迭代求解器进行求解，然后进行后处理：我们使用 `DataOut` 类创建一个输出文件，该文件可以通过常见的可视化程序进行可视化。

### 解决线性系统

对于有限元程序来说，我们最终得到的线性系统相对较小：由于我们使用的网格是 \(32 \times 32\)，因此矩阵的大小为 \(1089 \times 1089\)，网格中有 \(32^2 = 1089\) 个顶点。在许多后续的教程程序中，矩阵大小通常在几万到十几万之间，并且在如 ASPECT 这样的基于 deal.II 的代码中，我们定期解决超过一亿个方程的问题（尽管是使用并行计算机）。无论如何，即使对于这里的小系统，矩阵也远大于本科生或大多数研究生课程中通常遇到的大小，因此出现了我们如何解决此类线性系统的问题。

解决线性系统的第一种方法通常是高斯消元法。这种方法的问题在于它所需的操作数量与 \(N^3\) 成正比，其中 \(N\) 是线性系统中的方程或未知数的数量——更具体地说，操作数量约为 \(23N^3\)，大致如此。对于 \(N=1089\)，这意味着我们需要进行大约 8.61 亿次操作。这是一个相当可行的数字，现代处理器在不到 0.1 秒的时间内就可以完成。然而，显然这无法扩展：如果我们在线性系统中有二十倍的方程（也就是二十倍的未知数），那么它将需要 1000 到 10000 秒，或者大约一个小时。如果将线性系统再扩大十倍，我们显然无法在单台计算机上解决它。

通过意识到矩阵中只有相对较少的条目是非零的（即，矩阵是稀疏的），我们可以在一定程度上拯救局面。高斯消元法的变体可以利用这一点，从而显著加快处理速度；我们将在第 29 步中首次使用 `SparseDirectUMFPACK` 类实现的这种方法，以及后面的一些其他方法。这些高斯消元法的变体可能使我们能够处理大约 100,000 到 200,000 的问题大小，但无法超出这个范围。

相反，我们在这里要采用一个 1952 年的想法：共轭梯度法，简称“CG”。CG 是一种“迭代”求解器，它形成一个收敛到精确解的向量序列；实际上，在没有舍入误差的情况下，经过 \(N\) 次这样的迭代，如果矩阵是对称且正定的，它会找到精确解。这种方法最初被开发为另一种求解线性系统的方式，像高斯消元法一样，但作为这种方法并没有太多的优势，几十年来被遗忘。但是，当计算机变得足够强大以解决高斯消元法不再有效的大小问题时（大约在 1980 年代），CG 被重新发现，因为人们意识到它非常适合像有限元方法所得到的大型稀疏系统。这是因为 (i) 它计算的向量收敛到精确解，因此，只要我们对合理的近似解满意，我们实际上不必进行所有 \(N\) 次迭代来找到精确解；(ii) 它只需要矩阵-向量乘法，这对于稀疏矩阵非常有用，因为稀疏矩阵的定义是只有 \(O(N)\) 条目，因此矩阵-向量乘法可以用 \(O(N)\) 的努力完成，而对密集矩阵则需要 \(N^2\) 次操作。因此，我们可以希望用最多 \(O(N^2)\) 的操作来解决线性系统，许多情况下会更少。

因此，有限元代码几乎总是使用迭代求解器，例如 CG，来解决线性系统，我们在此代码中也将这样做。（我们注意到，CG 方法仅适用于对称且正定的矩阵；对于其他方程，矩

阵更不规则，或者存在负特征值等，可能需要使用其他方法。）实际上，在这段代码中，我们将用到 `SolverCG` 类，这个类的工作方式与求解器的类结构非常相似。

### 组装的实现

从我们已经讨论的内容中，您的任务是：实现给定有限元形状函数（如 `FE_Poly` 或 `FE_Q`），组装所需的矩阵和右侧向量。

为了使事情变得简单一些，我们将首先实现 `assemble_system()` 函数，它的工作原理是从我们希望在程序中添加到每个有限元的实例中读取数据，正如我们在上面的讨论中看到的。尽管对于每个单元，您都必须计算一组 \(A_{ij}\) 和 \(F_i\)，但这可以在单个循环中完成；同时，您可以在同一时刻填充矩阵和向量。

### 构建计算的框架

最后，我们必须注意到，由于处理矩阵和向量的方式，`SparseMatrix` 和 `Vector` 类不允许简单地使用 `operator[]` 对元素进行访问。因为这些类采用了稀疏存储，因此它们不具有以简单方式寻址的便利性。我们将用到“访问器”来获取元素的位置。对于 `SparseMatrix` 对象，访问器称为 `SparseMatrix::iterator`，而对于 `Vector` 对象，它称为 `Vector::iterator`。这两个类都可以通过引用使用并且大部分使用类似的方式，因此我们可以采用相同的名称（例如 `A` 和 `F`）来引用每个类的访问器。

---

如果您需要进一步的修改或额外的翻译，请告诉我！
<!--stackedit_data:
eyJoaXN0b3J5IjpbNDI0NTQ0OTE4LC0xOTE5NDY0NDM0LDIwOT
U0NjY0NCwtNzkzMTE2MjQwLC04ODgwNTYwMDZdfQ==
-->