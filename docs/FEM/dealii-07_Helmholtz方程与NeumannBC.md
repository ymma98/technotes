# step-7, Helmholtz方程与NeumannBC


# 正确性验证

可能从来没有一个非平凡的有限元程序从一开始就能够正常工作。因此，有必要找到方法来验证计算出的解是否正确。通常，这是通过选择一种仿真设置来实现的，假设我们知道精确的连续解并评估连续解与计算的离散解之间的差异。如果这种差异以正确的收敛阶次收敛到零，那么这通常是正确性的一个良好指示，尽管可能还有其他来源的误差，它们对总误差的贡献较小，或者是高阶误差。在有限元仿真的背景下，这种通过选择适当的右端项和边界条件来选取解的方法通常被称为 **制造解法**。（我们将在下文中讨论我们如何在该方法中构造解，讨论我们要解决的方程之后。）

在这个例子中，我们不会深入讨论系统软件验证的理论，这通常是一个复杂的问题。相反，我们将展示 deal.II 在这方面能提供的工具。这主要集中在一个单一函数 `VectorTools::integrate_difference()` 的功能上。该函数计算给定连续函数与有限元场在每个单元上的不同范数。当然，像任何其他积分一样，我们只能使用求积公式来评估这些范数；因此，选择合适的求积公式对于准确评估误差至关重要。特别是对于 \( L_{\infty} \) 范数，我们仅在求积点上评估数值解和精确解的最大偏差；因此，不应尝试使用仅在存在超收敛的点（例如最低阶高斯求积公式的高斯点）进行评估的求积规则，因为这些求积公式在矩阵组装时是正确的（例如，对于线性元素，不应使用 `QGauss(2)` 求积公式）。事实上，这通常也是对其他范数的良好建议：如果你的求积点恰巧选在误差较小的位置，由于超收敛，计算出的误差看起来比实际小得多，甚至可能会建议更高的收敛阶次。因此，我们将为这些误差范数的积分选择不同于线性系统组装的求积公式。

函数 `VectorTools::integrate_difference()` 在三角剖分的每个单元 \( K \) 上评估所需的范数，并返回一个包含每个单元这些值的向量。通过这些局部值，我们可以获得全局误差。例如，如果向量 \( e \) 包含所有单元 \( K \) 的元素 \( e_K \)，并包含局部 \( L_2 \) 范数 \( \|u - u_h\|_K \)，那么

\[
E = \left( \sum_K e_K^2 \right)^{1/2}
\]
就是全局的 \( L_2 \) 误差 \( E = \|u - u_h\|_{\Omega} \)。

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5Nzg5ODYwMDEsMTc1NDYxNjY5M119
-->