# 赵隐剑老师_并行编程入门实践课程 02

* 该笔记对应以下 b 站视频，主要讲 MPI 的使用
	*  [并行编程入门与实践4](https://www.bilibili.com/video/BV1PQU2YvE8J/?spm_id_from=333.788.recommend_more_video.4&vd_source=b7bbd99721bfe117cc47d14c9f45af86)

其它 MPI 教程:
	* [Paul Norvig's Guide](https://www.paulnorvig.com/guides/using-mpi-with-c.html) 本篇笔记主要参考的是这个

[TOC]


---

## MPI

MPI（Message Passing Interface），主要是处理进程之间消息通信。

编译:

```cpp
mpic++ main.cpp -o main
mpirun -np 4 ./main
```


* 例子

```cpp
#include <mpi.h>        // MPI header for parallel functions
#include <iostream>     // For std::cout, std::endl
#include <thread>       // For std::this_thread::sleep_for
#include <chrono>       // For std::chrono::seconds

int main(int argc, char* argv[]) {
    // Initialize the MPI execution environment
    MPI_Init(&argc, &argv);

    // Retrieve the rank (ID) of this process and the total number of processes
    int rank = 0;
    int size = 0;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    std::cout << "mpi_i, mpi_n: " << rank << ", " << size << std::endl;

    // Sleep for a short duration to mimic the original behavior
    // Using std::this_thread::sleep_for and std::chrono provides type safety and clarity
    std::this_thread::sleep_for(std::chrono::seconds(1));

    // Synchronize all processes at this barrier
    // No process moves past this point until all have reached it
    MPI_Barrier(MPI_COMM_WORLD);

    // Only the root process (rank 0) performs this action
    if (rank == 0) {
        std::cout << "Only 0 does this." << std::endl;
    }

    // Cleanly shut down the MPI execution environment
    MPI_Finalize();

    return 0; // Indicate successful execution
}
```


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTY0ODc3MzkwMiwtNzAyODgzODg5LC0yOD
YwODY2NzQsLTE1NTk3MDkxNDgsNzYyNDQ4MjkwLDE3NzUyMDg3
MTJdfQ==
-->